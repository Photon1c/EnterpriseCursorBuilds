Recreating the Wireframe Style with Three.js (Technical Guide)
The following guide outlines how to reproduce this classic 1980s wireframe city look using Three.js in a web browser. We will focus on achieving a minimalist, neon-green outline style in a modern 3D context (essentially creating our own “flyover” of a city in wireframe) while staying faithful to the original’s visual constraints – meaning no textured surfaces or realistic lighting, just luminous green lines on black. The setup can be integrated into a 4D map context (i.e. an interactive 3D map with a time dimension for animation) by animating the camera over time.
Generating a Grid-Based Wireframe City Model
To simulate a city like Manhattan in wireframe, we need to create a set of 3D building models and then render only their edges. There are a few ways to generate the city geometry:
Simple procedural blocks – For example, you could create a grid of rectangular buildings with varying heights. In code, this might involve two nested loops (for X and Z coordinates) placing buildings at regular intervals (to mimic city blocks). Each building can be a Three.js BoxGeometry sized according to the desired building footprint and height. Random or planned height values will give variation to the skyline. You can also leave some grid cells empty to represent streets or plazas, forming a street grid pattern.
Using real map data (optional) – For a more authentic city layout, you could use real building footprint data or a heightmap. For instance, using extruded polygons from OpenStreetMap for Manhattan or any city: each building footprint could be extruded to its height. This is more complex, but libraries or GIS data can assist. However, even a rough grid of blocks can convey the idea without needing every building exact – remember, the original effect was somewhat abstract. Aim for a cluster of rectangular forms that read as a city skyline.
Once you have the solid building geometries, the critical step is to render them as wireframes (outlines only). In Three.js, the most straightforward way is to use an edges or wireframe helper geometry. There are two common approaches:
Use built-in wireframe mode – Three.js materials like MeshBasicMaterial have a boolean wireframe property. If you set material.wireframe = true, the object will be drawn as wireframe lines. However, this mode will draw all the triangle edges of the geometry, including internal diagonals on each face (because every rectangular face is made of two triangles). For a simple box building, this means you’d see an X across each face, which isn’t the authentic look we want (real wireframe displays typically omit the interior face diagonals). So this approach is quick, but not ideal for a clean outline.
Use an EdgesGeometry helper – Three.js provides THREE.EdgesGeometry which extracts just the sharp edges of a mesh (edges where two faces meet at an angle)​
STACKOVERFLOW.COM
. This is perfect for our needs, because it will give us only the perimeter outline of each building and not the unnecessary interior lines​
STACKOVERFLOW.COM
. For example, a rectangular box will yield its 12 outer edges. To use it, you take a mesh’s geometry and create an EdgesGeometry from it, then render that as line segments. According to the official Three.js docs, it only takes a couple of lines of code:
js
Copy
Edit
// Given a BoxGeometry for a building:
const edges = new THREE.EdgesGeometry(boxGeometry);
const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 }); 
const wireframe = new THREE.LineSegments(edges, lineMaterial);
scene.add(wireframe);
This converts the boxGeometry into a set of line segments (wireframe) drawn in bright green. We use LineBasicMaterial for the lines. The result is that only the sharp edges of the box are drawn in the scene​
THREEJS.ORG
. You would do this for each building geometry you created (or reuse one material for all the lines). Note: LineBasicMaterial by default renders thin lines; if you need slightly thicker lines, you might try linewidth, but most browsers ignore that property for WebGL – achieving thicker lines requires advanced techniques or post-processing, so it’s best to stick with the default thin lines which mimics the vector monitor look.
Ground grid and other details – To emulate the grid lines on the ground (like roads or a coordinate grid), you can do something similar: create a large flat grid of lines. An easy way is to use THREE.GridHelper: for example const grid = new THREE.GridHelper(size, divisions, color, color); where color is green. This will generate a flat grid of lines along the XZ plane. You can make the grid spacing correspond to city block size. Another method is to manually create a PlaneGeometry and subdivide it so that EdgesGeometry will produce a lattice of lines. For instance, new THREE.PlaneGeometry(width, depth, nx, nz) with a subdivision for each block – then use EdgesGeometry on it to get the street lines. Either way, including a ground grid can enhance the sense of perspective as the camera moves, just as the film’s effect had a street map visible in wireframe. Add the grid to the scene the same way (as line segments) and position it at ground level (e.g. y = 0 if your buildings’ bases start at y=0).
Finally, when constructing the scene, be sure to position your city model appropriately. In Three.js, the coordinate system might have Y as up. So, if you created buildings with their base at y=0, you might need to raise them so the camera can see them well. In the film, the view was an aerial one looking slightly downward at Manhattan. You can mirror that by positioning the camera above the city looking down (we’ll cover camera in the next section). The overall scale can be adjusted as needed, but try to keep building proportions somewhat consistent (e.g., for Manhattan, buildings (the WTC towers) were much taller than they were wide, etc.). Performance tip: If your city has a huge number of buildings (many line segments), you might eventually want to merge geometries or use instancing for efficiency. But for a moderate number of buildings, simply adding many LineSegments objects is fine. Since we are not using complex shaders or textures, the scene should remain relatively lightweight. Also, the aesthetic benefits from a bit of sparsity – you don’t need every tiny detail drawn, just enough outlines to suggest the city shape.
Simulating a Camera Fly-through
With the 3D wireframe city in place, the next step is to simulate the flyover camera movement – like Snake Plissken’s point-of-view as he glides over the city. In a “4D map” context, time is the fourth dimension, represented by the moving camera through the 3D space. There are a couple of ways to implement a smooth camera flight in Three.js:
Manual animation loop: You can directly animate the camera’s position and orientation inside the render loop (requestAnimationFrame). For example, suppose you want the camera to start north of the city and fly south toward a landing point. You might set an initial position, e.g. camera.position.set(0, 300, -1000) (if we treat positive Z as south and Y as altitude), and a target position near the city center or a specific building. Each frame, you incrementally move the camera a little closer to the target. This could be as simple as:
js
Copy
Edit
// Pseudocode inside your render loop:
camera.position.z += 5;    // move forward (south) by 5 units each frame
camera.position.y -= 1;    // descend slightly
camera.lookAt(cityCenter); // keep camera pointed at the city (or specific target)
You would adjust the increments to control speed. Using camera.lookAt() ensures the camera stays focused on the city as it moves. This method gives you fine control – you can change speed or direction based on time or triggers. For example, to simulate the glider leveling out, you might decrease the descent rate as you approach the landing.
Tweening libraries: For smoother or more complex motion, you can use a tweening library like GSAP (GreenSock) or Tween.js to interpolate camera properties. With a tween, you specify start and end values for the camera’s position (and maybe where it looks), and the library will animate it over a set duration with easing. For instance, using Tween.js:
js
Copy
Edit
// Using Tween.js to animate camera from current position to target over 5 seconds
new TWEEN.Tween(camera.position).to({ x: 0, y:150, z:0 }, 5000)
  .easing(TWEEN.Easing.Quadratic.InOut)
  .start();
And similarly tween the lookAt target or use onUpdate to call camera.lookAt(...). Tweening will handle the interpolation for you, resulting in a smooth glide without having to manually update each frame. This approach is useful if you want the camera to follow a predefined path or sequence of key points (waypoints). You can chain multiple tweens or use curves (like a Catmull-Rom spline through points) for more complex flight paths.
Fly controls (interactive): If you want a free-flight interactive camera (not pre-scripted, but user-controlled like a “God mode” fly-through), Three.js offers FlyControls​
THREEJS.ORG
. This control scheme allows the user to use keyboard/mouse to move the camera in 3D space (similar to first-person shooter noclip mode). FlyControls continuously moves the camera based on input, which could simulate a manual flyover. However, for recreating the cinematic opening scene, an automated camera on rails (with possibly limited user oversight) is closer to the film. You can choose either approach depending on your needs (scripted cinematic vs. interactive exploration).
In our case (mimicking Escape from NY), a scripted camera path is appropriate. Imagine the camera as the glider: start from a high point north of the city, pointed towards Manhattan, then descend and move forward, banking slightly if needed. You might also introduce slight rotations for realism – e.g., a gentle oscillation or roll as if the glider is catching some turbulence, but subtle enough not to break the “computer-stable” feel. Keep in mind the original interface was supposed to be from the aircraft’s instrumentation, which might be gyro-stabilized, so a mostly steady movement with smooth turns is desirable. Implementing the fly-through: Set up your Three.js scene with a PerspectiveCamera (with a somewhat wide field of view, maybe 60–75°, to capture a broad swath of the city). A wider FOV can exaggerate perspective and make the city appear to rush toward the viewer, which enhances the motion feeling. Position the camera at the desired start. Then use either a loop or tween as described to move it. Make sure to call renderer.render(scene, camera) on each frame update. For a 4D map integration, you might tie the camera position to a timeline or UI slider representing time. For example, at time T=0 the camera is at start, at T=100 it’s at the end. Then update camera based on the time value. This way a user could scrub or the animation could sync with other data.
Shaders and Materials for the Neon Green Outline
Achieving the neon green outline look in Three.js mostly comes down to using the right materials and shader settings to get bright unshaded lines, just like the film’s high-contrast visuals. Here are the key techniques and settings:
Unlit, solid color material: Use materials that don’t respond to light and just render a constant color. THREE.LineBasicMaterial({ color: 0x00ff00 }) is ideal for the wireframe lines – it produces a flat green color for the lines regardless of any lights in the scene. Similarly, if you use any meshes for black surfaces (for occlusion or background), use THREE.MeshBasicMaterial({ color: 0x000000 }) so they render as flat black. Avoid Lambert, Phong, Standard, etc., because those expect lighting and can create gradients or highlights which we do not want. In the film sequence, the lines had a uniform glow. Using BasicMaterial ensures our green lines are uniformly colored (the brightness won’t fall off with distance or angle).
Emissive glow (optional): If you did want the lines to have a slight glow or bloom (that “neon” intensity), you have a couple of options. One is to use a post-processing bloom filter (Three.js has UnrealBloomPass, for instance) to make bright areas bleed a bit. Another lightweight trick: you can give the line material a slightly lower opacity and draw the lines multiple times to simulate a glow. But these are likely overkill if our goal is faithful minimalism – the original effect, while bright, did not have a strong bloom, it was more like crisp CRT lines. So, using just a pure color might be truer to the source. You could also set the material’s transparent to true and opacity to, say, 0.8, which might visually soften the lines, but be careful as that can cause depth sorting issues for many overlapping lines. In most cases, solid opaque lines are fine.
No surfaces or fills: Ensure that only the lines are visible. If you have added actual mesh objects for buildings purely for collision/occlusion purposes, you’ll want them not to be rendered as visible solids. Using a pure black BasicMaterial on them can effectively hide them against a black background (more on background in the next section). Alternatively, you could set those meshes’ renderOrder or material depthWrite such that they only serve to occlude the lines behind but do not appear themselves. A simple approach: give every building a black material and also draw the wireframe lines. Since the lines are green and drawn after, they will show up on edges. The faces of buildings will be black on black background – essentially invisible. This mimics how the practical effect used black-painted buildings to hide surfaces. As an extra measure, you can disable shadows and any lighting calculations entirely.
Shader customization: For most purposes, you won’t need a custom shader – the standard materials handle this look. But if you wanted to replicate details like an old monitor’s scanlines or a slight flicker, you could write a custom fragment shader to modulate the line brightness or color. This is beyond the scope of a basic setup, but worth mentioning. A fragment shader could, for example, darken every other horizontal line to simulate scanlines, or wiggle the line vertices slightly over time for a “distorted signal” effect. These effects can add authenticity if you’re going for a really retro monitor vibe. Keep them subtle if used. For now, we can stick to the straightforward approach: bright green lines drawn with no special shading needed.
Color choice: The classic color is a pure green. In hex, #00FF00 is a fully saturated green. Some monitors or films have a slightly teal or yellowish tinge; you can experiment with neon greens (like #33FF33 or similar) to see what feels right. The film’s look is basically a medium-bright green. You might avoid very dark or very light greens – too dark and it won’t “pop”, too light (toward white) and it loses that CRT feel. A mid neon green gives the best pop against black.
Lighting and Background for a Retro-Futuristic Tone
To maintain the retro-futuristic tone of the scene, we need to set up lighting and background in a minimalist way. In the original, the “world” is just a black void with glowing lines – there is no real sky, no realistic light source, as it’s supposed to be an abstract computer representation. Here’s how to replicate that:
Background as pure black: Set the scene’s background to black. In Three.js you can do scene.background = new THREE.Color(0x000000) or set the renderer clear color to black. This gives the canvas a solid black backdrop, just like the night sky (or an empty monitor background). It’s important for contrast – the green lines will stand out strongly. Do not use fog or any background images; keep it empty. If you want, you could add a subtle starfield if simulating a night sky, but in Escape from NY’s context, the view was through a computer, so it likely wouldn’t show stars – it was just a grid representation. So best to leave it plain black.
Lighting: You actually do not need any lights in the scene for the wireframe effect, and it’s recommended to either use none or minimal lights. If all materials are MeshBasicMaterial or LineBasicMaterial, they are unlit and will appear the same regardless of lights. In fact, adding lights could accidentally illuminate any black geometry you have (making it visible grey, which we don’t want). The safest route: no lights at all, or if you have one, maybe a very dim ambient light just to ensure any non-emissive material stays dark. Since we are essentially doing an outline visualization, we rely on emissive color. One scenario to consider: if you opted to use a standard mesh (Lambert/Phong) for some reason, you’d then need lights for it to show – but we have no reason to do that here. So, skip the lights; they’re not needed for the desired aesthetic. This mirrors the film’s approach: the only “light” in the wireframe sequence is the glow of the lines themselves.
Occlusion using black geometry: As mentioned, you might include solid black meshes for buildings or ground simply to block lines behind them. If you do this, ensure these meshes do not receive any unintended lighting. Setting their material to pure black and ambientLight to something like 0x000000 (if using older three versions) or just using BasicMaterial which isn’t affected by light will do the trick. They will essentially be invisible against the black background, except where they overlap the green lines (in which case they’ll hide portions of lines behind, creating proper depth sorting). This technique was analogous to how the physical model’s black buildings obscured the far edges. In Three.js, depth testing by default will take care of this: if a green line of a far building goes behind a nearer black-surfaced building, that portion of the line will be hidden. The viewer only sees the front-most outlines, enhancing realism.
Atmospheric effects: Avoid modern effects like haze, fog, lens flares, etc. They would break the retro look. The original wireframe had a very clean appearance – no atmospheric perspective (the lines in the distance were just as bright as those in front)​
BEFORESANDAFTERS.COM
, because a computer display wouldn’t simulate aerial haze. To mimic that, do not fade out lines with distance (no fog). Everything should be equally crisp. If anything, you could mimic the limited resolution of an old display by slightly reducing detail at far distances (for example, not drawing extremely far-off buildings), but this is optional. Keeping it simple often works best.
HUD elements (optional): In the film, part of the tone came from the overlay text (“NOSE VIEW”, “ALT 5.35”, etc.) which gave it a military tech feel. In Three.js, you can add such heads-up-display elements by drawing 2D text on a transparent overlay canvas or using CSS, or even by creating flat planes with text textures (though that introduces a texture). If you want to include these, keep the font a simple vector-looking font (like a monospaced or seven-segment style) and color it the same green. This little addition can enhance the retro-futuristic vibe. Make sure the text always faces the camera (if 3D) or is part of the HTML overlay. Again, this is extra – the core aesthetic is the wireframe city itself.
By following these lighting and background guidelines, you ensure that nothing detracts from the bright green wireframe. The scene should feel like an old-school computer rendering: black void and luminous grid lines, exactly as in Escape from New York’s glider sequence.
Embracing a Minimalist 80s Look
To conclude, remember that less is more when replicating this style. The original visual was constrained by what couldn’t be done in 1981 – no color shading, no textures, no fancy reflections. By intentionally limiting our Three.js scene to basic geometry and flat lines, we not only stay faithful to the film, but we also capture the retro charm. Here are final tips to maintain authenticity:
Use low-poly geometry – Buildings don’t need beveled edges or complex shapes. Simple extruded rectangles and prisms suffice. In fact, a certain blockiness is desirable (think of how coarse the model was in reality). Avoid curvy or highly detailed models; those would stand out against the simplistic rendering.
Avoid realism enhancements – Don’t accidentally turn on features like shadows, ambient occlusion, or texture maps. A shadow of one building on another, for instance, would never appear on a 1980s wireframe display. If your Three.js app has global effects turned on (sometimes some examples enable shadows by default), disable them for this scene.
Color palette – Stick to the single green tone for lines. If you introduce additional colors, do it sparingly (for example, the film briefly showed a red dot for a target). Too many colors will break the monochrome look. One idea: use a slightly different shade of green or blue for the ground grid vs. building edges, if you want to differentiate them, but keep both in the same family of retro CRT colors (green/cyan). Often, pure green across everything is fine.
Resolution and line quality – Vector displays had pin-sharp but jaggy lines (no anti-aliasing). You might consider turning off antialiasing in the renderer for a more jagged pixelated line look (Three.js WebGL renderer has an antialias option you can set to false). This will make the lines look harsher, which can add to the 80s computer feel. Alternatively, keep them smooth if you prefer clarity – that’s an artistic choice. Both can evoke a retro feel in different ways.
By combining all the above techniques, you can recreate a convincing neon wireframe city flythrough in a modern browser. The end result should look like a slice of early-CGI sci-fi: a green wire-grid Manhattan (or any city) with a camera smoothly gliding over it. This homage to Escape from New York’s opening scene not only is fun to build, but also showcases how stylistic constraints from an earlier era can be reimagined with today’s tools. Happy coding, and welcome to 1981!